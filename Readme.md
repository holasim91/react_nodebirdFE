# NodeBird FE Part

# NextJS
    next에는 react-hot-loader가 적용되어 있어서 자동으로 새로고침이 된다
    
    
# Ant Design
    일본에서 고통받았던 그것. 
    https://ant.design/ 에서 자세한 것 확인하기
    Form태그의 onFinish는 자동으로 e.preventDefault()가 적용되어있다.()

# 반응형
    프론트 화면을 개발할 때에는 무조건 모바일 화면부터 디자인하고 점점 늘려라.
    반대로하면.. 헬게이트 오픈!
    gutter: 컬럼사이 너무 딱 붙어있지 않게 간격을 주는 것

# Component Container나누기
    예전에는 순수하게 화면만 보여주는 곳을 Component, 데이터를 다루는 컴포넌트는 Container로 나누었으나 hooks가 도입되면서 리액트 공식팀에서 그 둘을 나누는 것을 추천하지 않는다.

# Link/Next
    Link에 href에 넣는게 좋다 a에는 넣지 말구

# useCallback
    컴포넌트에 함수를 넘겨주는 경우 꼭 사용해라

# CSS Inline-Style
    안하는게 좋다.

    ```javascript
        {} === {} //false 이기 떄문에 불필요한 렌더링이 발생하기 때문

    ```
    따라서 Styled-Components를 사용해서 스타일링을 하자
# 리렌더링
    Virtual Dom이 최초 렌더링 된것과 비교해서 다른 것이 있을 때 그것만 다시 그린다.
    함수형 컴포넌트에서 리렌더링이 된다고 함은 함수 안의 부분이 전부 다시 실행되는 것이 맞다.
    근데, useCallback에서 두번째 인자로 받는 (배열 안) 것이 바뀌지 않는이상 같은 것으로 친다(캐싱이니까).
    리턴 부분 안에서 바뀐 것만 다시 실행됨
    

# useCallback VS UseMemo
    useCallback은 함수를 캐싱하고, useMemo는 값을 캐싱한다.

# Hooks을 쓸 수 있는 조건
    반복문이나 조건문, 함수내에서는 사용 못한다.

# 왜 리덕스인가?
    부모컴포넌트에서 자식 컴포넌트에게로 일일이 데이터를 보내주는 것이 번거롭기 때문에 고안된 것(중앙저장소 역할)
    에러가 나면 쉽게 해결 가능하지만 코드양이 엄청 늘어남
    비동기 요청 할 때 좋아

# 불변성
    JS에서 무적권 조심해야하는 개념
    {} === {} //false
    const a = {}
    const b = a
    a === b // true
    객체를 참조관계가 있으면 참이다.
    그렇다면 리덕스에서 왜 객체를 새로 만드는가(return{...state, blah})? 새로 만들어야 변경내역이 추적이된다.
    그런데 왜 안쪽은 참조를 하는가? 메모리 관리를 위해
    
# Redux Thunk
    리덕스의 미들웨어(미들웨어는 리덕스의 기능을 향상시켜주는 것)
    리덕스가 비동기 액선을 디스패치 할 수 있도록 해준다.
    Thunk는 지연된 함수라는 뜻
  
# Thunk vs Saga
  Thunk는 짧은 대신에 딜레이 같은 것을 줘야할 때 JS로 기능을 자신이 만들어야한다
  그러나 Saga는 딜레이 기능을 지원하는등 암튼 편의기능 많음. 암튼 많음
    

# SAGA Effect
    all : all은 배열을 받고 그 안에 있는 것들을 한방에 실행한다.
    fork: 함수를 실행한다. 비동기 함수를 호출한다. 결과가 리턴되기도 전에 바로 다음것을 실행한다.
    call: 얘도 함수를 실행하는데 동기함수를 호출한다.
    put: 
    take: take안에 있는 액션이 실행될 때까지 기다리겠다. 근데 이건 딱 한번만 실행되기때문에, 안에 while문을 써야한다. 하지만 이 경우엔 동기적으로 동작하지만 코드가 직관적이지 않음
    takeEvery: take안의 while문을 대체하기위한 표현. 비동기적
    takeLatest: 마지막것만(동시에 로딩중인것만, 완료된 것은 나두고...프론트에서만 그렇게 생각함 즉 요청은 두번하는데 응답을 하나만 받는다 이밀이야) 실행
    takeLeading: 처음것만
    throttle: 지정한 시간안에 한 번만 요청할 수 있게한다.